\subsubsection{Executable Memory Allocation}

Once the code has been generated, it needs memory allocated to hold the final executable \texttt{x86}. Typical memory allocation techniques such as \texttt{new} or \texttt{malloc} are unsuitable for these purposes as the memory allocated by them is non-executable; instead, they only have \texttt{read} and \texttt{write} permissions. This is done for security purposes, as it prevents many instances of arbitrary code execution exploits by restricting execution on general purpose memory.

In order to work around this, the executable memory allocator developed uses \texttt{Win32} APIs to change the permissions of the allocated memory; in specific, it uses \texttt{VirtualProtect} \cite{win32-VirtualProtect} to change the permissions to \texttt{PAGE\_EXECUTE\_READWRITE} \cite{win-mem-protection}. This allows the contents of the memory to be executed directly without the operating system throwing an exception. Upon destruction, the allocator restores the permission of the touched memory to \texttt{PAGE\_READWRITE}.

Typically, we allocate as much memory as needed when required; if the generated code required \texttt{x} bytes of memory, then we would simply allocate \texttt{x} bytes on demand. In the case of executable memory, however, it is not so simple. The memory protection status discussed earlier does not have byte level granularity, but instead is at the page level. This means we would must make page aligned allocations in order to not disrupt the permissions of surrounding allocations. The \texttt{Win32} API \texttt{VirtualQuery} \cite{win32-VirtualQuery} is used to determine the page boundary, allowing the allocator to guarantee it only changes permissions on pages that it has full ownership over. The C++11 specifier \texttt{alignas} \cite{cpp-alignas} is used to force page alignment on automatically managed allocations (such as stack allocations).

In order to guarantee full ownership over the page, the allocation must span over the entire page (inclusive of alignments). Allocating an entire page for every compiled block would be extremely wasteful as pages in Windows are \texttt{4096} bytes large whereas the generated code for a given block rarely exceeds \texttt{100} bytes. To work around this, the allocator internally allocates a buffer of memory spanning a whole number of pages and sets the permissions appropriately; when the compiler then requests an allocation of size \texttt{x}, the allocator simply hands out an \texttt{x} byte portion of the pre-allocated memory, and no further allocations are performed.