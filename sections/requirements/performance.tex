\subsection{Performance}

The performance of the JIT will need to be evaluated in comparison to the JIT emulator to analyse and conclude if the JIT does indeed accelerate emulation. Given that different programs will give different performance characteristics, a range of program sizes and structures will need to be explored. These include:

\begin{itemize}
    \item \textbf{Short Simple Programs}
    
    In short and simple programs, especially those without many jumps, the fixed overhead costs of the emulator such as initialization time will become more significant. Many test suites will be written for this including basic single instruction suites, such as the \texttt{xor} suite, will be written to investigate the performance characteristics.
    
    \item \textbf{Long Complex Programs}
    
    Conversely, in longer running tests initialization time and fixed overheads become amortized. These tests are of particular importance as the performance of the emulator becomes more important for longer tests. Test suites will be written with long running times and large source codes to investigate the performance characteristics.

    \item \textbf{Memory Intensive}
    
    Memory instructions can be difficult to accelerate due to the abstraction required to fully emulate the entire memory space whilst running in the same process as the emulator. Because of this, the JIT emulator may see little speedup over the emulator. Test suites such as \texttt{memcpy(n)} will be written to investigate the performance characteristics.

    \item \textbf{Arithmetic Intensive}
    
    Conversely, arithmetic operations can be executed very close to the metal with minimal abstraction, providing the JIT emulator with an opportunity for a large speedup over the interpreter. Test suites such as \texttt{primal(n)} will be written to investigate the performance characteristics.

    \item \textbf{Iteration}
    
    Programs and functions with a high degree of iteration, such as those with hot loops, tend to invoke the same blocks of code over and over again. This will be interesting to investigate as it's expected that the JIT's relative performance to the interpreter will increase. To test this, test suites designed with hot loops, such as \texttt{primal(n)} will be designed. The suite will cover the same loops being executed from a few times to very many times, allowing us to see how the performance characteristics of the JIT and emulator systems evolve as the loops get more frequently executed, and at which point, if any, the JIT emulator surpasses the interpreter.

    \item \textbf{Recursion}
    
    Similar to iteration, heavily recursive functions cause the same blocks to be executed many times, however they have a higher load on the memory instructions due to the stack operations required. Recursive test suites such as \texttt{fibonacci(n)} and \texttt{factorial(n)} will be created to investigate how the performance characteristics of recursive programs differ to that of iterative programs.
\end{itemize}
