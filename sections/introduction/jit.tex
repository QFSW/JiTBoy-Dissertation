\subsection{Why a JIT?}

Binary translation, and in general, execution of any program, can be handled with one of 3 fundamental techniques.

\begin{itemize}
    \item Interpretation
    \item Ahead of Time (AOT) Compilation
    \item Just in Time (JIT) Compilation
\end{itemize}

Binary translators are typically implemented as interpreters. This is the easiest and most widespread \JWComment{Citation for that claim?} way to emulate a system as interpreting is fairly easy and is largely agnostic of the host system. However, it has a large per instruction overhead as the interpretation needs to be executed every time the instruction is emulated.

AOT compilation is typically the fastest technique of execution, as the program is fully translated to the native host machine code before execution. Since compilation is only needed once, much more time can be spent on aggressive optimisations to improve the performance of the generated code. In practice, it is impossible to statically and comprehensively determine which contents of a program correspond to instructions and what corresponds to data, especially with the possibility of self modifying code. Given this, an AOT compiler is not a solution that could be extended to commercial grade emulators as its emulation correctness is fundamentally limited. \JWComment{I'd be very surprised if AOT compilers sacrifice \emph{correctness}. Presumably, in the face of uncertainty, they would just pick the `safe' option, no? Which rather conflicts with your earlier claim that AOT always gives the best performance. It seems to me that interpretation and AOT compilation have different pros and cons -- interpretation has all the runtime information available to it, so can make really precise decisions, but has a high overhead and can't do optimisations; AOT compilation has much less data available to it so has to make conservative decisions to ensure correctness, but can do optimisations and the code it generates has no overhead.}

JIT compilation strikes a balance between the two. Some unit of source code, which I will refer to as a source block, is compiled just before it is needed for execution. This is not as fast as a full AOT compiler because the full compilation needs to occur at runtime; it can, however, have a much lower per instruction execution overhead than an interpreter, if implemented well. It provides the following advantages over an AOT compiler

\begin{itemize}
	\item Self modifying programs can be supported as the compiler exists and is present at the time of execution
	\item The latency of execution, or the time to first execution, is lower because the entire program does not need to be compiled before execution can begin
	\item The machine code can be generated specifically for the host system, allowing system-specific optimisations to be made such as the use of modern ISA extensions, e.g. SIMD
	\item Tiered compilation techniques can be supported as the execution can be analysed for hotpaths, which can then be recompiled with greater optimisations
	\item Highly dynamic language features, such as those involving runtime code generation, can be supported. An example of this is allowing a regex to be JIT compiled to an extremely fast FSM
\end{itemize}

With everything considered, a JIT compiler is the best option to achieve greater performance over an interpreter without fundamentally sacrificing correctness. \JWComment{This discussion is all excellent -- really well argued and very clearly written. I'd just like to see lots of citations to back up all your claims.}
