\subsection{Why a JIT?}

\YIComment{Improve this section}

Binary translation, and in general, execution of any program, can be handled with one of three fundamental techniques.

\begin{itemize}
    \item Interpretation
    \item Ahead of Time (AOT) Compilation
    \item Just in Time (JIT) Compilation
\end{itemize}

Binary translators are typically implemented as interpreters. This is a widespread technique for system emulation as interpreting is fairly easy and largely agnostic of the host system. However, it has a large per-instruction overhead as the interpretation needs to be executed every time the instruction is emulated.

AOT compilation can be the fastest technique of execution, as the program is fully translated to the native host machine code before execution. Since compilation is only needed once, much more time can be spent on aggressive optimisations to improve the performance of the generated code. On the other hand, the lack of runtime knowledge prevents the AOT compiler from making any host specific optimisations. AOT compilers are limited by the fact that all decisions must be made statically, and none can be deferred to execution time. In practice, it is impossible to statically and comprehensively determine which contents of a program correspond to instructions and what corresponds to data, especially with the possibility of self modifying code. Given this, an AOT compiler alone is not a solution that could be extended to commercial-grade emulators as its emulation correctness is fundamentally limited to what it can statically determine to be executable code.

JIT compilation strikes a balance between the two. Some unit of source code, which we will refer to as a source block, is compiled just before it is needed for execution. This is typically not as fast as a full AOT compiler because the full compilation needs to occur at runtime, adding additional runtime costs; it can, however, have a much lower per-instruction execution overhead than an interpreter, if implemented well. It provides the following advantages over an AOT compiler:

\begin{itemize}
	\item Self modifying programs can be supported as the compiler exists and is present at the time of execution.
	
	\item The latency of execution, or the time to first execution, is lower because the entire program does not need to be compiled before execution can begin.
	
	\item The machine code can be generated specifically for the host system, allowing system-specific optimisations to be made such as the use of modern ISA extensions, e.g. SIMD.
	
	\item Tiered compilation techniques can be supported as the execution can be analysed for hotpaths, which can then be recompiled with greater optimisations.
	
	\item Highly dynamic language features, such as those involving runtime code generation, can be supported. An example of this is allowing a regex to be JIT compiled to an extremely fast finite state machine (FSM).
\end{itemize}

With everything considered, a JIT compiler is the best option to achieve greater performance over an interpreter without fundamentally sacrificing correctness. \JW{You enumerate several advantages of JIT over AOT but it feels a bit incomplete without a comparison of JIT against interpreter too. I wonder if a nice table is called for. You could have three columns: interpreter, JIT, and AOT, and then various rows like `support for self-modifying programs' and `execution latency', and then write a brief comment in each cell.} \JW{By the time of your final report, I expect you'll have made more progress on the `hybrid' approach, and so you'll want to talk about the idea of the hybrid approach in your introduction too.}
