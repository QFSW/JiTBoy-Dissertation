\subsection{Why a JIT?}

Binary translation, and in general, execution of any program, can be handled with one of 3 fundamental techniques.

\begin{itemize}
    \item Interpretation
    \item Ahead of Time (AOT) Compilation
    \item Just in Time (JIT) Compilation
\end{itemize}

Binary translators are typically implemented as interpreters. This is a widespread technique for system emulation as interpreting is fairly easy and largely agnostic of the host system. However, it has a large per instruction overhead as the interpretation needs to be executed every time the instruction is emulated.

AOT compilation is typically the fastest technique of execution, as the program is fully translated to the native host machine code before execution. Since compilation is only needed once, much more time can be spent on aggressive optimisations to improve the performance of the generated code. AOT compilers are limited by the fact that all decisions must be made statically, and none can be deferred to execution time. In practice, it is impossible to statically and comprehensively determine which contents of a program correspond to instructions and what corresponds to data, especially with the possibility of self modifying code. Given this, an AOT compiler alone is not a solution that could be extended to commercial grade emulators as its emulation correctness is fundamentally limited to what it can statically determine to be executable code.

JIT compilation strikes a balance between the two. Some unit of source code, which I will refer to as a source block, is compiled just before it is needed for execution. This is not as fast as a full AOT compiler because the full compilation needs to occur at runtime; it can, however, have a much lower per instruction execution overhead than an interpreter, if implemented well. It provides the following advantages over an AOT compiler:

\begin{itemize}
	\item Self modifying programs can be supported as the compiler exists and is present at the time of execution
	\item The latency of execution, or the time to first execution, is lower because the entire program does not need to be compiled before execution can begin
	\item The machine code can be generated specifically for the host system, allowing system-specific optimisations to be made such as the use of modern ISA extensions, e.g. SIMD
	\item Tiered compilation techniques can be supported as the execution can be analysed for hotpaths, which can then be recompiled with greater optimisations
	\item Highly dynamic language features, such as those involving runtime code generation, can be supported. An example of this is allowing a regex to be JIT compiled to an extremely fast FSM
\end{itemize}

With everything considered, a JIT compiler is the best option to achieve greater performance over an interpreter without fundamentally sacrificing correctness.
