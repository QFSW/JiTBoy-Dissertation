\subsection{Academia}
\label{section:background-academia}

Several papers have investigated utilizing JIT compilation to accelerate binary emulation, otherwise known as dynamic binary translation (DBT). Mark Probst \cite{mark-probst-dbt} and others \cite{nigel-jit} investigate a JIT-Interpreter hybrid to emulate foreign binary programs. Unlike the hybrid model proposed, I will be exploring a concurrent architecture to exploit the multiple cores present on modern CPUs.

Typically, a well written JIT system's bottleneck will be the compilation latency as opposed to the execution time. Several papers \cite{js-concurrent-trace, dynamic-compilation-early} explored a hybrid model to mitigate this in which the execution and compilation are decoupled from the main thread. In this hybrid system one or more worker threads are responsible for compiling blocks in the background, with a fallback emulator used on the main thread when compiled blocks are not ready. This is a technique I will be exploring with my JIT-Interpreter hybrid. BÃ¶hm \cite{igor-phd} explores optimisations to a concurrent system including how to determine when and what to compile; my project does not initially aim to explore this in depth and is left as further work. \JW{I find the preceding two paragraphs a bit confusing. From the first paragraph it sounds like JIT/interpreter hybrids have been studied before, but your work is novel because you're exploiting additional threads to do the compilation. But then in the second paragraph you mention works that do this multi-threaded hybrid approach already. So I don't think it makes sense to differentiate yourself from Probst's work by saying that you go multi-threaded, if you're then going to cancel that out by saying that other works have already gone multi-threaded. Do you see what I mean? I think you need to say something about how your work differs from the works you cite in the second paragraph. This might just be ``we're doing MIPS and they did a different architecture'', but ideally it would be something more fundamentally different about your technique.}

FX!32 \cite{fx!32} developed by Digital allows Alpha platforms to emulate x86 Windows applications, but takes a different approach to optimising performance. Initial emulation runs purely under an interpreter, which builds an execution profile of the program. Using this, FX!32 uses a background optimizer to generate efficient native code that is used in subsequent runs. Whilst this provided good results, it fundamentally relies on inter-run improvements, something out of the scope of this project. It does not perform any JIT acceleration for new programs.